#include "catch2/catch_test_macros.hpp"
#include "catch2/matchers/catch_matchers_vector.hpp"
#include "catch2/generators/catch_generators.hpp"

#include "util/nibble.hpp"

using Catch::Matchers::Equals;

// Note: Does not test other types than 64-bit type

TEST_CASE("nibble4", "[utility][nibble]")
{
	std::vector<uint8_t> _test = {
		0b00010000, 0b00110010, 0b01010100, 0b01110110,
		0b10011000, 0b10111010, 0b11011100, 0b11111110},
		_verify = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
	SECTION("range")
	{
		for (int i = 0; i < 16; ++i)
		{
			auto _out = nibble4(_test, i);
			CHECK(_out == _verify[i]);
		}
	}
	SECTION("copy")
	{
		std::vector<uint8_t> _out(16);
		nibble4Copy(_test, _out);
		CHECK_THAT(_out, Equals(_verify));
	}
}

TEST_CASE("nibble MC13", "[utility][nibble]")
{
	uint16_t bits = GENERATE(1, 2, 3, 4, 5, 6, 8, 10, 14, 16, 32);
	std::vector<uint64_t> _test = {
		0b00000000'11111110'00000011'11110000'00111110'00001111'00001110'00110010U,
		0b10101010'00000000'00111111'11110000'00000011'11111110'00000000'11111111U};
	std::vector<std::vector<uint64_t>> _verify(32, std::vector<uint64_t>());
	_verify[0] = { // 1
		0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
		1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
		0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
		0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
		1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1};
	_verify[1] = { // 2
		0b10, 0b00, 0b11, 0b00, 0b10, 0b11, 0b00, 0b00,
		0b11, 0b11, 0b00, 0b00, 0b10, 0b11, 0b11, 0b00,
		0b00, 0b00, 0b11, 0b11, 0b11, 0b00, 0b00, 0b00,
		0b10, 0b11, 0b11, 0b11, 0b00, 0b00, 0b00, 0b00,
		0b11, 0b11, 0b11, 0b11, 0b00, 0b00, 0b00, 0b00,
		0b10, 0b11, 0b11, 0b11, 0b11, 0b00, 0b00, 0b00,
		0b00, 0b00, 0b11, 0b11, 0b11, 0b11, 0b11, 0b00,
		0b00, 0b00, 0b00, 0b00, 0b10, 0b10, 0b10, 0b10};
	_verify[2] = { // 3
		0b010, 0b110, 0b000, 0b111, 0b000, 0b110, 0b011, 0b000,
		0b110, 0b111, 0b000, 0b000, 0b111, 0b111, 0b000, 0b000,
		0b110, 0b111, 0b011, 0b000, 0b000, 0b110, 0b111, 0b111,
		0b000, 0b000, 0b000, 0b111, 0b111, 0b111, 0b000, 0b000,
		0b000, 0b110, 0b111, 0b111, 0b011, 0b000, 0b000, 0b000,
		0b010, 0b101};
	_verify[3] = { // 4
		0b0010, 0b0011, 0b1110, 0b0000, 0b1111, 0b0000, 0b1110, 0b0011,
		0b0000, 0b1111, 0b0011, 0b0000, 0b1110, 0b1111, 0b0000, 0b0000,
		0b1111, 0b1111, 0b0000, 0b0000, 0b1110, 0b1111, 0b0011, 0b0000,
		0b0000, 0b1111, 0b1111, 0b0011, 0b0000, 0b0000, 0b1010, 0b1010};
	_verify[4] = { // 5
		0b10010, 0b10001, 0b00011, 0b11110, 0b00000, 0b11111, 0b00000,
		0b11110, 0b00011, 0b10000, 0b11111, 0b00001, 0b10000, 0b11111,
		0b00011, 0b00000, 0b11110, 0b11111, 0b00000, 0b00000, 0b11111,
		0b11111, 0b00000, 0b00000, 0b01010};
	_verify[5] = { // 6
		0b110010, 0b111000, 0b110000, 0b000011, 0b111110,
		0b000000, 0b111111, 0b000000, 0b111110, 0b000011,
		0b110000, 0b111111, 0b000000, 0b111000, 0b111111,
		0b000000, 0b110000, 0b111111, 0b000011, 0b000000,
		0b101010};
	_verify[7] = { // 8
		0b00110010, 0b00001110, 0b00001111, 0b00111110,
		0b11110000, 0b00000011, 0b11111110, 0b00000000,
		0b11111111, 0b00000000, 0b11111110, 0b00000011,
		0b11110000, 0b00111111, 0b00000000, 0b10101010};
	_verify[9] = { // 10
		0b1000110010, 0b1111000011, 0b1111100000,
		0b1111000000, 0b1000000011, 0b0000111111,
		0b1111110000, 0b0000000011, 0b1111111110,
		0b0000000000, 0b1111111111, 0b0000000000};
	_verify[13] = { // 14
		0b00111000110010, 0b11100000111100,
		0b11111100000011, 0b11111110000000,
		0b11111100000000, 0b11100000000011,
		0b00000000111111, 0b00111111111100,
		0b10101000000000};
	_verify[15] = { // 16
		0b0000111000110010, 0b0011111000001111,
		0b0000001111110000, 0b0000000011111110,
		0b0000000011111111, 0b0000001111111110,
		0b0011111111110000, 0b1010101000000000};
	_verify[31] = { // 32
		0b00111110000011110000111000110010,
		0b00000000111111100000001111110000,
		0b00000011111111100000000011111111,
		0b10101010000000000011111111110000};
	SECTION("range")
	{
		INFO("bits " << bits);
		for (std::size_t i = 0; i < _verify[bits-1].size(); ++i)
		{
			auto a = MC13::nibble(_test, i, bits);
			INFO("i " << i);
			REQUIRE(a == _verify[bits-1][i]);
		}
	}
	SECTION("copy")
	{
		INFO("bits " << bits);
		std::vector<uint64_t> _out(_verify[bits-1].size());
		MC13::nibbleCopy(_test, _out, bits);
		REQUIRE_THAT(_out, Equals(_verify[bits-1]));
	}
}

TEST_CASE("nibble MC16", "[utility][nibble]")
{
	uint16_t bits = GENERATE(1, 2, 3, 4, 5, 6, 8, 10, 14, 16, 32);
	std::vector<uint64_t> _test = {
		0b00000000'11111110'00000011'11110000'00111110'00001111'00001110'00110010U,
		0b10101010'00000000'00111111'11110000'00000011'11111110'00000000'11111111U};
	std::vector<std::vector<uint64_t>> _verify(32, std::vector<uint64_t>());
	_verify[0] = { // 1
		0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0,
		1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0,
		0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
		0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
		1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,
		0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,
		0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,
		0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1};
	_verify[1] = { // 2
		0b10, 0b00, 0b11, 0b00, 0b10, 0b11, 0b00, 0b00,
		0b11, 0b11, 0b00, 0b00, 0b10, 0b11, 0b11, 0b00,
		0b00, 0b00, 0b11, 0b11, 0b11, 0b00, 0b00, 0b00,
		0b10, 0b11, 0b11, 0b11, 0b00, 0b00, 0b00, 0b00,
		0b11, 0b11, 0b11, 0b11, 0b00, 0b00, 0b00, 0b00,
		0b10, 0b11, 0b11, 0b11, 0b11, 0b00, 0b00, 0b00,
		0b00, 0b00, 0b11, 0b11, 0b11, 0b11, 0b11, 0b00,
		0b00, 0b00, 0b00, 0b00, 0b10, 0b10, 0b10, 0b10};
	_verify[2] = { // 3 <
		0b010, 0b110, 0b000, 0b111, 0b000, 0b110,
		0b011, 0b000, 0b110, 0b111, 0b000, 0b000,
		0b111, 0b111, 0b000, 0b000, 0b110, 0b111,
		0b011, 0b000, 0b000,
		0b111, 0b111, 0b011, 0b000, 0b000, 0b100,
		0b111, 0b111, 0b011, 0b000, 0b000, 0b000,
		0b111, 0b111, 0b111, 0b001, 0b000, 0b000,
		0b000, 0b101, 0b010};
	_verify[3] = { // 4
		0b0010, 0b0011, 0b1110, 0b0000, 0b1111, 0b0000, 0b1110, 0b0011,
		0b0000, 0b1111, 0b0011, 0b0000, 0b1110, 0b1111, 0b0000, 0b0000,
		0b1111, 0b1111, 0b0000, 0b0000, 0b1110, 0b1111, 0b0011, 0b0000,
		0b0000, 0b1111, 0b1111, 0b0011, 0b0000, 0b0000, 0b1010, 0b1010};
	_verify[4] = { // 5 <
		0b10010, 0b10001, 0b00011, 0b11110, 0b00000, 0b11111,
		0b00000, 0b11110, 0b00011, 0b10000, 0b11111, 0b00001,
		0b11111, 0b00111, 0b00000, 0b11100, 0b11111, 0b00001,
		0b00000, 0b11110, 0b11111, 0b00001, 0b00000, 0b10100};
	_verify[5] = { // 6 <
		0b110010, 0b111000, 0b110000,
		0b000011, 0b111110, 0b000000,
		0b111111, 0b000000, 0b111110,
		0b000011,
		0b111111, 0b000011, 0b100000,
		0b111111, 0b000011, 0b000000,
		0b111111, 0b001111, 0b000000,
		0b101000,};
	_verify[7] = { // 8
		0b00110010, 0b00001110, 0b00001111, 0b00111110,
		0b11110000, 0b00000011, 0b11111110, 0b00000000,
		0b11111111, 0b00000000, 0b11111110, 0b00000011,
		0b11110000, 0b00111111, 0b00000000, 0b10101010};
	_verify[9] = { // 10 <
		0b1000110010, 0b1111000011, 0b1111100000,
		0b1111000000, 0b1000000011, 0b0000111111,
		0b0011111111, 0b1110000000, 0b0000111111,
		0b1111000000, 0b0000111111, 0b1010000000};
	_verify[13] = { // 14 <
		0b00111000110010, 0b11100000111100,
		0b11111100000011, 0b11111110000000,
		0b00000011111111, 0b00111111111000,
		0b11111100000000, 0b00000000001111};
	_verify[15] = { // 16
		0b0000111000110010, 0b0011111000001111,
		0b0000001111110000, 0b0000000011111110,
		0b0000000011111111, 0b0000001111111110,
		0b0011111111110000, 0b1010101000000000};
	_verify[31] = { // 32
		0b00111110000011110000111000110010,
		0b00000000111111100000001111110000,
		0b00000011111111100000000011111111,
		0b10101010000000000011111111110000};
	SECTION("range")
	{
		INFO("bits " << bits);
		for (std::size_t i = 0; i < _verify[bits-1].size(); ++i)
		{
			auto a = MC16::nibble(_test, i, bits);
			INFO("i " << i);
			REQUIRE(a == _verify[bits-1][i]);
		}
	}
	SECTION("copy")
	{
		INFO("bits " << bits);
		std::vector<uint64_t> _out(_verify[bits-1].size());
		MC16::nibbleCopy(_test, _out, bits);
		REQUIRE_THAT(_out, Equals(_verify[bits-1]));
	}
}
