#include "catch2/catch.hpp"

#include "format/nbt.hpp"
#include "util/endianess.hpp"

#include <vector>

template<typename T>
std::tuple<T, T> createMinMax(NBT::Endianess end)
{
	auto _min = std::numeric_limits<T>::min(), _max = std::numeric_limits<T>::max();
	if (end == NBT::ENDIAN_BIG)
	{
		endianess::toBig<T>(_min, (uint8_t *)&_min);
		endianess::toBig<T>(_max, (uint8_t *)&_max);
	}
	else
	{
		endianess::toLittle<T>(_min, (uint8_t *)&_min);
		endianess::toLittle<T>(_max, (uint8_t *)&_max);
	}
	return std::make_tuple(_min, _max);
}

TEST_CASE("NBT", "[format]")
{
	auto empty_value = [](const NBT::Value &) { return false; };
	auto quick_reader = [&empty_value](
		std::vector<uint8_t> _test,
		std::function<bool(const NBT::Tag &)> f,
		NBT::Endianess end)
	{
		return NBT::Reader().parse(_test, f, empty_value, end);
	};
	SECTION("root")
	{
		auto end = GENERATE(NBT::ENDIAN_BIG, NBT::ENDIAN_LITTLE);
		auto dist = quick_reader({10, 0, 0, 0},
			[](const NBT::Tag & t) {
				CHECK(t.getName() == "");
				return false;
			}, end);
		REQUIRE(dist == 4);
	}
	SECTION("endianess")
	{
		auto check_data = [](const NBT::Tag & t) {
			if (t.type() == NBT::TAG_Compound)
				CHECK(t.getName() == "a");
			else
				CHECK(t.getName() == "");
			return false;
		};
		SECTION("big")
		{
			auto dist = quick_reader({10, 0, 1, 'a', 0}, check_data, NBT::ENDIAN_BIG);
			REQUIRE(dist == 5);
		}
		SECTION("little")
		{
			auto dist = quick_reader({10, 1, 0, 'a', 0}, check_data, NBT::ENDIAN_LITTLE);
			REQUIRE(dist == 5);
		}
	}
	SECTION("Value")
	{
		using Catch::Matchers::Equals;
		auto end = GENERATE(NBT::ENDIAN_BIG, NBT::ENDIAN_LITTLE);
		SECTION("end")
		{
			NBT::Value val(end);
			val.set();
			REQUIRE(val.type() == NBT::TAG_End);
		}
		SECTION("int8")
		{
			NBT::Value val(end);
			val.set(std::numeric_limits<int8_t>::max());
			REQUIRE(val.type() == NBT::TAG_Byte);
			REQUIRE(val.get<int8_t>() == std::numeric_limits<int8_t>::max());
		}
		SECTION("int16")
		{
			NBT::Value val(end);
			val.set(std::numeric_limits<int16_t>::max());
			REQUIRE(val.type() == NBT::TAG_Short);
			REQUIRE(val.get<int16_t>() == std::numeric_limits<int16_t>::max());
		}
		SECTION("int32")
		{
			NBT::Value val(end);
			val.set(std::numeric_limits<int32_t>::max());
			REQUIRE(val.type() == NBT::TAG_Int);
			REQUIRE(val.get<int32_t>() == std::numeric_limits<int32_t>::max());
		}
		SECTION("int64")
		{
			NBT::Value val(end);
			val.set(std::numeric_limits<int64_t>::max());
			REQUIRE(val.type() == NBT::TAG_Long);
			REQUIRE(val.get<int64_t>() == std::numeric_limits<int64_t>::max());
		}
		SECTION("float")
		{
			NBT::Value val(end);
			val.set(std::numeric_limits<float>::max());
			REQUIRE(val.type() == NBT::TAG_Float);
			REQUIRE(val.get<float>() == std::numeric_limits<float>::max());
		}
		SECTION("double")
		{
			NBT::Value val(end);
			val.set(std::numeric_limits<double>::max());
			REQUIRE(val.type() == NBT::TAG_Double);
			REQUIRE(val.get<double>() == std::numeric_limits<double>::max());
		}
		SECTION("string")
		{
			NBT::Value val(end);
			val.set("test");
			REQUIRE(val.type() == NBT::TAG_String);
			REQUIRE(val.get<NBT::NBTString>() == "test");
		}
		SECTION("byte array")
		{
			NBT::Value val(end);
			std::vector<int8_t> src{0, std::numeric_limits<int8_t>::min(), std::numeric_limits<int8_t>::max()};
			NBT::NBTByteArray _test{src.data(), src.data() + src.size()};
			std::vector<int8_t> _verify{0, std::numeric_limits<int8_t>::min(), std::numeric_limits<int8_t>::max()};
			val.set(_test);
			REQUIRE(val.type() == NBT::TAG_Byte_Array);
			auto dst{val.get<NBT::NBTByteArray>()};
			REQUIRE_THAT((std::vector<int8_t>{dst.begin(), dst.end()}), Equals(std::vector<int8_t>{_verify.begin(), _verify.end()}));
		}
		SECTION("int array")
		{
			auto minmax = createMinMax<int32_t>(end);
			NBT::Value val(end);
			std::vector<int32_t> src{0, std::get<0>(minmax), std::get<1>(minmax)};
			NBT::NBTIntArray _test{src.data(), src.data() + src.size()};
			std::vector<int32_t> _verify{0, std::numeric_limits<int32_t>::min(), std::numeric_limits<int32_t>::max()};
			val.set(_test);
			REQUIRE(val.type() == NBT::TAG_Int_Array);
			auto dst{val.get<NBT::NBTIntArray>()};
			REQUIRE_THAT((std::vector<int32_t>{dst.begin(), dst.end()}), Equals(std::vector<int32_t>{_verify.begin(), _verify.end()}));
		}
		SECTION("long array")
		{
			auto minmax = createMinMax<int64_t>(end);
			NBT::Value val(end);
			std::vector<int64_t> src{0, std::get<0>(minmax), std::get<1>(minmax)};
			NBT::NBTLongArray _test{src.data(), src.data() + src.size()};
			std::vector<int64_t> _verify{0, std::numeric_limits<int64_t>::min(), std::numeric_limits<int64_t>::max()};
			val.set(_test);
			REQUIRE(val.type() == NBT::TAG_Long_Array);
			auto dst{val.get<NBT::NBTLongArray>()};
			REQUIRE_THAT((std::vector<int64_t>{dst.begin(), dst.end()}), Equals(std::vector<int64_t>{_verify.begin(), _verify.end()}));
		}
		SECTION("compound")
		{
			NBT::Value val(end);
			val.set(NBT::TAG_Compound, 0);
			REQUIRE(val.type() == NBT::TAG_Compound);
		}
		SECTION("list")
		{
			NBT::Value val(end);
			auto _count = GENERATE(0, std::numeric_limits<int32_t>::max());
			val.set(NBT::TAG_List, _count);
			REQUIRE(val.type() == NBT::TAG_List);
			REQUIRE(val.count() == _count);
		}
	}
	SECTION("Tag")
	{
		auto end = GENERATE(NBT::ENDIAN_BIG, NBT::ENDIAN_LITTLE);
		NBT::Tag tag(end);
		auto test_name = "test";
		CHECK(tag.isName(""));
		CHECK(tag.getName() == "");
		tag.setName(test_name);
		CHECK(tag.isName(test_name));
		CHECK(tag.getName() == test_name);
	}
	SECTION("examples")
	{
		std::vector<uint8_t> small_test = {
			10, 0, 11, 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd',
				8, 0, 4, 'n', 'a', 'm', 'e', 0, 10,
					'B', 'a', 'n', 'a', 'n', 'a', 'r', 'a', 'm', 'a',
			0};
		std::vector<uint8_t> big_test = {
			0x0a, 0x00, 0x05, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x04, 0x00, 0x08, 0x6c, 0x6f, 0x6e, 0x67, 0x54, 
			0x65, 0x73, 0x74, 0x7f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x02, 0x00, 0x09, 0x73, 0x68, 
			0x6f, 0x72, 0x74, 0x54, 0x65, 0x73, 0x74, 0x7f, 0xff, 0x08, 0x00, 0x0a, 0x73, 0x74, 0x72, 0x69, 
			0x6e, 0x67, 0x54, 0x65, 0x73, 0x74, 0x00, 0x29, 0x48, 0x45, 0x4c, 0x4c, 0x4f, 0x20, 0x57, 0x4f, 
			0x52, 0x4c, 0x44, 0x20, 0x54, 0x48, 0x49, 0x53, 0x20, 0x49, 0x53, 0x20, 0x41, 0x20, 0x54, 0x45, 
			0x53, 0x54, 0x20, 0x53, 0x54, 0x52, 0x49, 0x4e, 0x47, 0x20, 0xc3, 0x85, 0xc3, 0x84, 0xc3, 0x96, 
			0x21, 0x05, 0x00, 0x09, 0x66, 0x6c, 0x6f, 0x61, 0x74, 0x54, 0x65, 0x73, 0x74, 0x3e, 0xff, 0x18, 
			0x32, 0x03, 0x00, 0x07, 0x69, 0x6e, 0x74, 0x54, 0x65, 0x73, 0x74, 0x7f, 0xff, 0xff, 0xff, 0x0a, 
			0x00, 0x14, 0x6e, 0x65, 0x73, 0x74, 0x65, 0x64, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x75, 0x6e, 
			0x64, 0x20, 0x74, 0x65, 0x73, 0x74, 0x0a, 0x00, 0x03, 0x68, 0x61, 0x6d, 0x08, 0x00, 0x04, 0x6e, 
			0x61, 0x6d, 0x65, 0x00, 0x06, 0x48, 0x61, 0x6d, 0x70, 0x75, 0x73, 0x05, 0x00, 0x05, 0x76, 0x61, 
			0x6c, 0x75, 0x65, 0x3f, 0x40, 0x00, 0x00, 0x00, 0x0a, 0x00, 0x03, 0x65, 0x67, 0x67, 0x08, 0x00, 
			0x04, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x07, 0x45, 0x67, 0x67, 0x62, 0x65, 0x72, 0x74, 0x05, 0x00, 
			0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x00, 0x0f, 0x6c, 
			0x69, 0x73, 0x74, 0x54, 0x65, 0x73, 0x74, 0x20, 0x28, 0x6c, 0x6f, 0x6e, 0x67, 0x29, 0x04, 0x00, 
			0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 
			0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x09, 0x00, 0x13, 0x6c, 0x69, 
			0x73, 0x74, 0x54, 0x65, 0x73, 0x74, 0x20, 0x28, 0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x75, 0x6e, 0x64, 
			0x29, 0x0a, 0x00, 0x00, 0x00, 0x02, 0x08, 0x00, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x0f, 0x43, 
			0x6f, 0x6d, 0x70, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x74, 0x61, 0x67, 0x20, 0x23, 0x30, 0x04, 0x00, 
			0x0a, 0x63, 0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x2d, 0x6f, 0x6e, 0x00, 0x00, 0x01, 0x26, 0x52, 
			0x37, 0xd5, 0x8d, 0x00, 0x08, 0x00, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x00, 0x0f, 0x43, 0x6f, 0x6d, 
			0x70, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x74, 0x61, 0x67, 0x20, 0x23, 0x31, 0x04, 0x00, 0x0a, 0x63, 
			0x72, 0x65, 0x61, 0x74, 0x65, 0x64, 0x2d, 0x6f, 0x6e, 0x00, 0x00, 0x01, 0x26, 0x52, 0x37, 0xd5, 
			0x8d, 0x00, 0x01, 0x00, 0x08, 0x62, 0x79, 0x74, 0x65, 0x54, 0x65, 0x73, 0x74, 0x7f, 0x07, 0x00, 
			0x65, 0x62, 0x79, 0x74, 0x65, 0x41, 0x72, 0x72, 0x61, 0x79, 0x54, 0x65, 0x73, 0x74, 0x20, 0x28, 
			0x74, 0x68, 0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x31, 0x30, 0x30, 0x30, 0x20, 0x76, 
			0x61, 0x6c, 0x75, 0x65, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x28, 0x6e, 0x2a, 0x6e, 0x2a, 0x32, 0x35, 
			0x35, 0x2b, 0x6e, 0x2a, 0x37, 0x29, 0x25, 0x31, 0x30, 0x30, 0x2c, 0x20, 0x73, 0x74, 0x61, 0x72, 
			0x74, 0x69, 0x6e, 0x67, 0x20, 0x77, 0x69, 0x74, 0x68, 0x20, 0x6e, 0x3d, 0x30, 0x20, 0x28, 0x30, 
			0x2c, 0x20, 0x36, 0x32, 0x2c, 0x20, 0x33, 0x34, 0x2c, 0x20, 0x31, 0x36, 0x2c, 0x20, 0x38, 0x2c, 
			0x20, 0x2e, 0x2e, 0x2e, 0x29, 0x29, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x3e, 0x22, 0x10, 0x08, 0x0a, 
			0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x04, 0x56, 0x4e, 0x50, 0x5c, 0x0e, 0x2e, 0x58, 0x28, 0x02, 
			0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0x0a, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 
			0x56, 0x1c, 0x50, 0x2a, 0x0e, 0x60, 0x58, 0x5a, 0x02, 0x18, 0x38, 0x62, 0x32, 0x0c, 0x54, 0x42, 
			0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 
			0x5a, 0x34, 0x18, 0x06, 0x62, 0x00, 0x0c, 0x22, 0x42, 0x08, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 
			0x52, 0x04, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 0x06, 0x30, 0x00, 0x3e, 
			0x22, 0x10, 0x08, 0x0a, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x04, 0x56, 0x4e, 0x50, 0x5c, 0x0e, 
			0x2e, 0x58, 0x28, 0x02, 0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0x0a, 0x48, 0x2c, 0x1a, 
			0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 0x0e, 0x60, 0x58, 0x5a, 0x02, 0x18, 0x38, 0x62, 
			0x32, 0x0c, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 
			0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x06, 0x62, 0x00, 0x0c, 0x22, 0x42, 0x08, 0x3c, 0x16, 
			0x5e, 0x4c, 0x44, 0x46, 0x52, 0x04, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 
			0x06, 0x30, 0x00, 0x3e, 0x22, 0x10, 0x08, 0x0a, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x04, 0x56, 
			0x4e, 0x50, 0x5c, 0x0e, 0x2e, 0x58, 0x28, 0x02, 0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 
			0x0a, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 0x0e, 0x60, 0x58, 0x5a, 
			0x02, 0x18, 0x38, 0x62, 0x32, 0x0c, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 
			0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x06, 0x62, 0x00, 0x0c, 0x22, 
			0x42, 0x08, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 0x52, 0x04, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 
			0x26, 0x28, 0x34, 0x4a, 0x06, 0x30, 0x00, 0x3e, 0x22, 0x10, 0x08, 0x0a, 0x16, 0x2c, 0x4c, 0x12, 
			0x46, 0x20, 0x04, 0x56, 0x4e, 0x50, 0x5c, 0x0e, 0x2e, 0x58, 0x28, 0x02, 0x4a, 0x38, 0x30, 0x32, 
			0x3e, 0x54, 0x10, 0x3a, 0x0a, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 
			0x0e, 0x60, 0x58, 0x5a, 0x02, 0x18, 0x38, 0x62, 0x32, 0x0c, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 
			0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x06, 
			0x62, 0x00, 0x0c, 0x22, 0x42, 0x08, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 0x52, 0x04, 0x24, 0x4e, 
			0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 0x06, 0x30, 0x00, 0x3e, 0x22, 0x10, 0x08, 0x0a, 
			0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x04, 0x56, 0x4e, 0x50, 0x5c, 0x0e, 0x2e, 0x58, 0x28, 0x02, 
			0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0x0a, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 
			0x56, 0x1c, 0x50, 0x2a, 0x0e, 0x60, 0x58, 0x5a, 0x02, 0x18, 0x38, 0x62, 0x32, 0x0c, 0x54, 0x42, 
			0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 
			0x5a, 0x34, 0x18, 0x06, 0x62, 0x00, 0x0c, 0x22, 0x42, 0x08, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 
			0x52, 0x04, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 0x06, 0x30, 0x00, 0x3e, 
			0x22, 0x10, 0x08, 0x0a, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x04, 0x56, 0x4e, 0x50, 0x5c, 0x0e, 
			0x2e, 0x58, 0x28, 0x02, 0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0x0a, 0x48, 0x2c, 0x1a, 
			0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 0x0e, 0x60, 0x58, 0x5a, 0x02, 0x18, 0x38, 0x62, 
			0x32, 0x0c, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 
			0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x06, 0x62, 0x00, 0x0c, 0x22, 0x42, 0x08, 0x3c, 0x16, 
			0x5e, 0x4c, 0x44, 0x46, 0x52, 0x04, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 
			0x06, 0x30, 0x00, 0x3e, 0x22, 0x10, 0x08, 0x0a, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x04, 0x56, 
			0x4e, 0x50, 0x5c, 0x0e, 0x2e, 0x58, 0x28, 0x02, 0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 
			0x0a, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 0x0e, 0x60, 0x58, 0x5a, 
			0x02, 0x18, 0x38, 0x62, 0x32, 0x0c, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 
			0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x06, 0x62, 0x00, 0x0c, 0x22, 
			0x42, 0x08, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 0x52, 0x04, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 
			0x26, 0x28, 0x34, 0x4a, 0x06, 0x30, 0x00, 0x3e, 0x22, 0x10, 0x08, 0x0a, 0x16, 0x2c, 0x4c, 0x12, 
			0x46, 0x20, 0x04, 0x56, 0x4e, 0x50, 0x5c, 0x0e, 0x2e, 0x58, 0x28, 0x02, 0x4a, 0x38, 0x30, 0x32, 
			0x3e, 0x54, 0x10, 0x3a, 0x0a, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 
			0x0e, 0x60, 0x58, 0x5a, 0x02, 0x18, 0x38, 0x62, 0x32, 0x0c, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 
			0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x06, 
			0x62, 0x00, 0x0c, 0x22, 0x42, 0x08, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 0x52, 0x04, 0x24, 0x4e, 
			0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 0x06, 0x30, 0x00, 0x3e, 0x22, 0x10, 0x08, 0x0a, 
			0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x04, 0x56, 0x4e, 0x50, 0x5c, 0x0e, 0x2e, 0x58, 0x28, 0x02, 
			0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0x0a, 0x48, 0x2c, 0x1a, 0x12, 0x14, 0x20, 0x36, 
			0x56, 0x1c, 0x50, 0x2a, 0x0e, 0x60, 0x58, 0x5a, 0x02, 0x18, 0x38, 0x62, 0x32, 0x0c, 0x54, 0x42, 
			0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 0x2a, 0x40, 0x60, 0x26, 
			0x5a, 0x34, 0x18, 0x06, 0x62, 0x00, 0x0c, 0x22, 0x42, 0x08, 0x3c, 0x16, 0x5e, 0x4c, 0x44, 0x46, 
			0x52, 0x04, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 0x06, 0x30, 0x00, 0x3e, 
			0x22, 0x10, 0x08, 0x0a, 0x16, 0x2c, 0x4c, 0x12, 0x46, 0x20, 0x04, 0x56, 0x4e, 0x50, 0x5c, 0x0e, 
			0x2e, 0x58, 0x28, 0x02, 0x4a, 0x38, 0x30, 0x32, 0x3e, 0x54, 0x10, 0x3a, 0x0a, 0x48, 0x2c, 0x1a, 
			0x12, 0x14, 0x20, 0x36, 0x56, 0x1c, 0x50, 0x2a, 0x0e, 0x60, 0x58, 0x5a, 0x02, 0x18, 0x38, 0x62, 
			0x32, 0x0c, 0x54, 0x42, 0x3a, 0x3c, 0x48, 0x5e, 0x1a, 0x44, 0x14, 0x52, 0x36, 0x24, 0x1c, 0x1e, 
			0x2a, 0x40, 0x60, 0x26, 0x5a, 0x34, 0x18, 0x06, 0x62, 0x00, 0x0c, 0x22, 0x42, 0x08, 0x3c, 0x16, 
			0x5e, 0x4c, 0x44, 0x46, 0x52, 0x04, 0x24, 0x4e, 0x1e, 0x5c, 0x40, 0x2e, 0x26, 0x28, 0x34, 0x4a, 
			0x06, 0x30, 0x06, 0x00, 0x0a, 0x64, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x54, 0x65, 0x73, 0x74, 0x3f, 
			0xdf, 0x8f, 0x6b, 0xbb, 0xff, 0x6a, 0x5e, 0x0b, 0x00, 0x0c, 0x69, 0x6e, 0x74, 0x41, 0x72, 0x72, 
			0x61, 0x79, 0x54, 0x65, 0x73, 0x74, 0x00, 0x00, 0x00, 0x0a, 0x5c, 0xf5, 0x8a, 0x1a, 0x68, 0x9e, 
			0x1e, 0x0c, 0x62, 0x4e, 0x91, 0x46, 0x47, 0x71, 0xd3, 0x6f, 0x1a, 0x5f, 0x4b, 0x5d, 0x47, 0x89, 
			0x89, 0x75, 0x73, 0xf8, 0xb1, 0xe4, 0x38, 0x99, 0x48, 0xd8, 0x7d, 0x20, 0x59, 0xad, 0x23, 0x08, 
			0xbf, 0x67, 0x0c, 0x00, 0x0d, 0x6c, 0x6f, 0x6e, 0x67, 0x41, 0x72, 0x72, 0x61, 0x79, 0x54, 0x65, 
			0x73, 0x74, 0x00, 0x00, 0x00, 0x05, 0x5c, 0xf5, 0x8a, 0x1a, 0x68, 0x9e, 0x1e, 0x0c, 0x62, 0x4e, 
			0x91, 0x46, 0x47, 0x71, 0xd3, 0x6f, 0x1a, 0x5f, 0x4b, 0x5d, 0x47, 0x89, 0x89, 0x75, 0x73, 0xf8, 
			0xb1, 0xe4, 0x38, 0x99, 0x48, 0xd8, 0x7d, 0x20, 0x59, 0xad, 0x23, 0x08, 0xbf, 0x67, 0x00
		};
		SECTION("test.nbt")
		{
			auto diff = quick_reader(small_test, [](const NBT::Tag & t) {
				if (t.isName("hello world"))
				{
					REQUIRE(t.type() == NBT::TAG_Compound);
					return false;
				}
				else if (t.isName("name"))
				{
					REQUIRE(t.type() == NBT::TAG_String);
					REQUIRE(t.get<NBT::NBTString>() == "Bananarama");
					return false;
				}
				else if (t.type() == NBT::TAG_End)
					return false;
				FAIL("Unknown tag");
				return false;
			}, NBT::ENDIAN_BIG);
			REQUIRE(diff == std::ptrdiff_t(small_test.size()));
		}
		SECTION("bigtest")
		{
			using Catch::Matchers::Equals;
			struct
			{
				bool level = false;
				bool nested_compound = false;
				bool nested_ham = false;
				bool nested_egg = false;
				int listTest_long_count = 0;
				int listTest_comp_count = 0;
				struct ListTest
				{
					NBT::NBTString name;
					long long created_on;
				} listTest_comp_curr;
				struct 
				{
					int8_t byteTest = 0;
					int16_t shortTest = 0;
					int32_t intTest = 0;
					int64_t longTest = 0;
					float floatTest = 0;
					double doubleTest = 0;
					NBT::NBTString stringTest;
					struct
					{
						struct
						{
							NBT::NBTString name;
							float value;
						} ham;
						struct
						{
							NBT::NBTString name;
							float value;
						} egg;
					} nested;
					std::vector<int64_t> listTest_long;
					std::vector<ListTest> listTest_comp;
					NBT::NBTByteArray byteArrayTest;
					NBT::NBTIntArray intArrayTest;
					NBT::NBTLongArray longArrayTest;
				} data;
			} state;
			auto diff = NBT::Reader().parse(big_test, [&state](const NBT::Tag & t) {
				if (!state.level)
				{
					if (t.type() == NBT::TAG_Compound && t.isName("Level"))
						state.level = true;
					else
						FAIL("Unknown tag before level: " << t.getName());
				}
				else if (state.nested_egg)
				{
					if (t.type() == NBT::TAG_End)
						state.nested_egg = false;
					else if (t.type() == NBT::TAG_String && t.isName("name"))
						state.data.nested.egg.name = t.get<NBT::NBTString>();
					else if (t.type() == NBT::TAG_Float && t.isName("value"))
						state.data.nested.egg.value = t.get<float>();
					else
						FAIL("Unknown tag for nested egg: " << t.getName());
				}
				else if (state.nested_ham)
				{
					if (t.type() == NBT::TAG_End)
						state.nested_ham = false;
					else if (t.type() == NBT::TAG_String && t.isName("name"))
						state.data.nested.ham.name = t.get<NBT::NBTString>();
					else if (t.type() == NBT::TAG_Float && t.isName("value"))
						state.data.nested.ham.value = t.get<float>();
					else
						FAIL("Unknown tag for nested hamd: " << t.getName());
				}
				else if (state.nested_compound)
				{
					if (t.type() == NBT::TAG_End)
						state.nested_compound = false;
					else if (t.type() == NBT::TAG_Compound)
					{
						if (t.isName("ham"))
							state.nested_ham = true;
						else if (t.isName("egg"))
							state.nested_egg = true;
						else
							FAIL("Unknown tag " << t.getName());
					}
					else
						FAIL("Unknown tag for nested compound test: " << t.getName());
				}
				else if (state.listTest_comp_count > 0)
				{
					if (t.type() == NBT::TAG_End)
					{
						state.listTest_comp_count -= 1;
						state.data.listTest_comp.push_back(state.listTest_comp_curr);
					}
					else if (t.type() == NBT::TAG_String && t.isName("name"))
						state.listTest_comp_curr.name = t.get<NBT::NBTString>();
					else if (t.type() == NBT::TAG_Long && t.isName("created-on"))
						state.listTest_comp_curr.created_on = t.get<int64_t>();
					else
						FAIL("Unknown tag for listTest (compound): " << t.getName());
				}
				else if (t.type() == NBT::TAG_Byte && t.isName("byteTest"))
					state.data.byteTest = t.get<int8_t>();
				else if (t.type() == NBT::TAG_Short && t.isName("shortTest"))
					state.data.shortTest = t.get<int16_t>();
				else if (t.type() == NBT::TAG_Int && t.isName("intTest"))
					state.data.intTest = t.get<int32_t>();
				else if (t.type() == NBT::TAG_Long && t.isName("longTest"))
					state.data.longTest = t.get<int64_t>();
				else if (t.type() == NBT::TAG_Float && t.isName("floatTest"))
					state.data.floatTest = t.get<float>();
				else if (t.type() == NBT::TAG_Double && t.isName("doubleTest"))
					state.data.doubleTest = t.get<double>();
				else if (t.type() == NBT::TAG_String && t.isName("stringTest"))
					state.data.stringTest = t.get<NBT::NBTString>();
				else if (t.type() == NBT::TAG_Byte_Array && t.isName("byteArrayTest "
						"(the first 1000 values of (n*n*255+n*7)%100, starting with n=0 (0, 62, 34, 16, 8, ...))"))
					state.data.byteArrayTest = t.get<NBT::NBTByteArray>();
				else if (t.type() == NBT::TAG_Int_Array && t.isName("intArrayTest"))
					state.data.intArrayTest = t.get<NBT::NBTIntArray>();
				else if (t.type() == NBT::TAG_Long_Array && t.isName("longArrayTest"))
					state.data.longArrayTest = t.get<NBT::NBTLongArray>();
				else if (t.type() == NBT::TAG_Compound && t.isName("nested compound test"))
					state.nested_compound = true;
				else if (t.type() == NBT::TAG_List && t.isName("listTest (long)"))
					state.listTest_long_count = t.count();
				else if (t.type() == NBT::TAG_List && t.isName("listTest (compound)"))
					state.listTest_comp_count = t.count();
				else if (t.type() == NBT::TAG_End)
					state.level = false;
				else
					FAIL("Unknown tag for level: " << t.getName());
				return false;
			}, [&state](const NBT::Value & v) {
				if (state.listTest_long_count > 0)
				{
					--state.listTest_long_count;
					if (v.type() == NBT::TAG_Long)
						state.data.listTest_long.push_back(v.get<int64_t>());
					else
						FAIL("Unknown value for listTest (long)");
				}
				else if (state.listTest_comp_count > 0)
					SUCCEED(); // Ignore
				else
					FAIL("Unknown value " << v.type());
				return false;
			},
			NBT::ENDIAN_BIG);
			CHECK(diff == std::ptrdiff_t(big_test.size()));
			CHECK_FALSE(state.level);
			CHECK_FALSE(state.nested_compound);
			CHECK_FALSE(state.nested_ham);
			CHECK_FALSE(state.nested_egg);
			CHECK(state.listTest_long_count == 0);
			CHECK(state.listTest_comp_count == 0);
			CHECK(state.data.byteTest == 127);
			CHECK(state.data.shortTest == 32767);
			CHECK(state.data.intTest == 2147483647);
			CHECK(state.data.longTest == 9223372036854775807);
			CHECK(state.data.floatTest == 0.49823147f);
			CHECK(state.data.doubleTest == 0.4931287132182315);
			CHECK(state.data.stringTest == u8"HELLO WORLD THIS IS A TEST STRING ÅÄÖ!");
			CHECK(state.data.nested.ham.name == "Hampus");
			CHECK(state.data.nested.ham.value == 0.75);
			CHECK(state.data.nested.egg.name == "Eggbert");
			CHECK(state.data.nested.egg.value == 0.5);
			CHECK_THAT(state.data.listTest_long, Equals(std::vector<int64_t>{11, 12, 13, 14, 15}));
			CHECK_THAT((std::vector<int32_t>{state.data.intArrayTest.begin(), state.data.intArrayTest.end()}), Equals(std::vector<int32_t>{
				1559595546, 1755192844, 1649316166, 1198642031, 442452829,
				1200195957, 1945678308, 949569752, 2099272109, 587775847}));
			CHECK_THAT((std::vector<int64_t>{state.data.longArrayTest.begin(), state.data.longArrayTest.end()}), Equals(std::vector<int64_t>{
				6698411866812456460, 7083758994932749167, 1900320431777876341,
				8356624702346184920, 9016305054147723111}));
			auto _byteList = std::vector<int8_t>(1000);
			for (std::size_t i = 0; i < _byteList.size(); ++i)
				_byteList[i] = (i*i*255+i*7)%100;
			CHECK_THAT((std::vector<int8_t>{state.data.byteArrayTest.begin(), state.data.byteArrayTest.end()}), Equals(_byteList));
			CHECK(state.data.listTest_comp[0].name == "Compound tag #0");
			CHECK(state.data.listTest_comp[0].created_on == 1264099775885LL);
			CHECK(state.data.listTest_comp[1].name == "Compound tag #1");
			CHECK(state.data.listTest_comp[1].created_on == 1264099775885LL);
		}

		SECTION("snbt")
		{
			NBT::to_snbt(big_test, NBT::ENDIAN_BIG);
		}
	}
}
